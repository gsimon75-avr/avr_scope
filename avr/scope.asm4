; Expected symbols (via -Dname=value in commandline)
; F_CPU cpu freq in Hz

include(boilerplate.m4)
include(iosyms.m4)

define({RECV_BUF_SIZE}, 4)
define({NUM_SAMPLES}, 800)
define({USE_BAUD}, BAUDVALUE(250000))
define({TRIG_HIST}, 4)
define({TRIG_NONE}, 0)
define({TRIG_RISING}, 1)
define({TRIG_FALLING}, 2)

; register mapping
define({trig_low}, r9)
define({trig_high}, r10)
define({trig_level}, r11)
define({usart_sreg_tmp}, r12)
define({adc_sreg_tmp}, r14)
; generic working registers: r16, r17
define({admux}, r22)
define({delay_counter_max}, r23)
define({cmd_start_adc}, r24)
define({trig_type}, r25)
; sample_ptr X[H,L] address of the next sample: r26, r27
; recv_ptr Y[H,L], used by recvd_push and recvd_pop: r28, r29

define({BAUDVALUE}, {eval((F_CPU / (8*($1))) - 1)})

; ------------------------------------------------------------------------------
.CSEG
.org 0
jmp(main)

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rjmp(USART_RX_vect)
nop

rjmp(USART_UDRE_vect)
nop()

rcall(trap)
nop()

rcall(trap)
nop

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

FUNCTION(trap)
    cli
    pop(r16)
    lsr(r16)
    lsr(r16)
    dec(r16)
    andi(r16, 0x0f)
    rcall(led_num)
    ldi(r16, 1)
    rcall(led_dot)
  LOC(q):
    rjmp(LOC(q))
ENDFUNC

FUNCTION(led_num)
    ; In: r16 = n
    ; Out: none
    ; Changes: SREG
    
    push(ZL)
    push(ZH)
    cpi(r16, 0x10)
    brsh(LOC(OFF))

    mov(ZL, r16)
    clr(ZH)
    addiw(ZL, ZH, led_b210 << 1)
    lpm(ZH, Z)
    in(ZL, PORTB)
    andi(ZL, 0xf8)
    or(ZL, ZH)
    out(PORTB, ZL)
    
    mov(ZL, r16)
    clr(ZH)
    addiw(ZL, ZH, led_d7654 << 1)
    lpm(ZH, Z)
    in(ZL, PORTD)
    andi(ZL, 0x0f)
    or(ZL, ZH)
    out(PORTD, ZL)
    pop(ZH)
    pop(ZL)
    ret()

  LOC(OFF):
    in(ZL, PORTB)
    andi(ZL, 0xf8)
    out(PORTB, ZL)
    
    in(ZL, PORTD)
    andi(ZL, 0x0f)
    out(PORTD, ZL)
    pop(ZH)
    pop(ZL)
    ret()
ENDFUNC ; led_num


FUNCTION(led_dot)
    ; In: r16 = onoff
    ; Out: none
    ; Changes: SREG
    cpi(r16, 0)
    breq(LOC(OFF))
    sbi(PORTD, 2)
    ret()
  LOC(OFF):
    cbi(PORTD, 2)
    ret()
ENDFUNC ; led_dot


FUNCTION(recvd_push)
    ; In: r16 = x
    ; Out: None
    ; Changes: Y
    ;
    ; check wrap -> store -> increment
    cpi(YH, (recv_buf + RECV_BUF_SIZE) >> 8)
    brlo(LOC(NO_WRAP_AROUND))
    cpi(YL, (recv_buf + RECV_BUF_SIZE) & 0xff)
    brlo(LOC(NO_WRAP_AROUND))
    ldi(YL, recv_buf & 0xff)
    ldi(YH, recv_buf >> 8)
  LOC(NO_WRAP_AROUND):
    st(Y+, r16)
    ret()
ENDFUNC ; recvd_push


FUNCTION(recvd_pop)
    ; In: none
    ; Out: r16 = x
    ; Changes: Y
    ;
    ; decrement -> load -> check wrap
    ld(r16, -Y)
    cpi(YH, recv_buf >> 8)
    brlo(LOC(WRAP_AROUND))
    brne(LOC(NO_WRAP_AROUND))
    cpi(YL, recv_buf & 0xff)
    brsh(LOC(NO_WRAP_AROUND))
  LOC(WRAP_AROUND):
    ldi(YL, (recv_buf + RECV_BUF_SIZE) & 0xff)
    ldi(YH, (recv_buf + RECV_BUF_SIZE) >> 8)
  LOC(NO_WRAP_AROUND):
    ret()
ENDFUNC ; recvd_pop


FUNCTION(recvd_pop_byte)
    ; In: none
    ; Out: r16 = x
    ; Changes: Y, r17
    rcall(recvd_pop)
    mov(r17, r16)
    rcall(recvd_pop)
    lsl(r16)
    lsl(r16)
    lsl(r16)
    lsl(r16)
    or(r16, r17)
    ret()
ENDFUNC ; recvd_pop_byte

FUNCTION(set_sample_rate)
    ; In: r16
    ; Delay = 16 + 8*N clks -> N = delay/8 - 2
    ; 0:   1 us =   16 clks, N =   0
    ; 1:   2 us =   32 clks, N =   2
    ; 2:   5 us =   80 clks, N =   8
    ; 3:  10 us =  160 clks, N =  18
    ; 4:  20 us =  320 clks, N =  38
    ; 5:  50 us =  800 clks, N =  98
    ; 6: 100 us = 1600 clks, N = 198
    ldi(cmd_start_adc, _BV(ADEN, ADSC) | 3) ; 2)
    ldi(delay_counter_max, 0)
    tst(r16)
    breq(LOC(DONE))
    ldi(delay_counter_max, 2)
    dec(r16)
    breq(LOC(DONE))
    ldi(cmd_start_adc, _BV(ADEN, ADSC) | 3)
    ldi(delay_counter_max, 8)
    dec(r16)
    breq(LOC(DONE))
    ldi(delay_counter_max, 18)
    dec(r16)
    breq(LOC(DONE))
    ldi(delay_counter_max, 38)
    dec(r16)
    breq(LOC(DONE))
    ldi(delay_counter_max, 98)
    dec(r16)
    breq(LOC(DONE))
    ldi(delay_counter_max, 198)
  LOC(DONE):
    mov(r16, delay_counter_max)
    andi(r16, 0x0f)
    rcall(led_num)
    ret()
ENDFUNC ; set_sample_rate

FUNCTION(USART_RX_vect)
    in(usart_sreg_tmp, SREG)
    push(r16)
    push(r17)

    lds(r16, UDR0)

    cpi(r16, 'S')
    breq(LOC(SET_SPEED))
    cpi(r16, 'R')
    breq(LOC(SET_VREF))
    cpi(r16, 'Z')
    breq(LOC(SET_ZERO))
    cpi(r16, 'T')
    breq(LOC(SET_TRIG_TYPE))
    cpi(r16, 'L')
    breq(LOC(SET_TRIG_LEVEL))

    cpi(r16, 'p')
    breq(LOC(SET_PWM_PRESCALER))
    cpi(r16, 't')
    breq(LOC(SET_PWM_TOTAL))
    cpi(r16, 'h')
    breq(LOC(SET_PWM_ACTIVE))

    cpi(r16, '0')
    brlt(LOC(DONE2))
    cpi(r16, '9' + 1)
    brge(LOC(NOT_09))
    subi(r16, '0')
    rjmp(LOC(DIGIT))

  LOC(NOT_09):
    cpi(r16, 'A')
    brlt(LOC(DONE))
    cpi(r16, 'F' + 1)
    brge(LOC(NOT_AF))
    subi(r16, 'A' - 10)
    rjmp(LOC(DIGIT))

  LOC(NOT_AF):
    cpi(r16, 'a')
    brlt(LOC(DONE))
    cpi(r16, 'f' + 1)
    brge(LOC(DONE))
    subi(r16, 'a' - 10)

  LOC(DIGIT):
    rcall(recvd_push)
  LOC(DONE2):
    rjmp(LOC(DONE))

  LOC(SET_SPEED):
    rcall(recvd_pop)
    rcall(set_sample_rate)
    rjmp(LOC(DONE))

  LOC(SET_VREF):
    rcall(recvd_pop)
    andi(admux, 0xff - _BV(REFS1))
    sbrc(r16, 0)
    ori(admux, _BV(REFS1)) ; ref=AVcc
    sts(ADMUX, admux)
    rjmp(LOC(DONE))

  LOC(SET_ZERO):
    rcall(recvd_pop)
    cbr(admux, 0x0f)
    andi(r16, 0x01)
    or(admux, r16)
    sts(ADMUX, admux)
    rjmp(LOC(DONE))

  LOC(SET_TRIG_TYPE):
    rcall(recvd_pop)
    andi(r16, 0x03)
    mov(trig_type, r16)
    rjmp(LOC(DONE))

  LOC(SET_TRIG_LEVEL):
    rcall(recvd_pop_byte)
    mov(trig_level, r16)
    mov(r17, r16)
    addi(r16, TRIG_HIST)
    brcs(LOC(TRIG_LEVEL_NOT_TOO_HIGH))
    ldi(r16, 0xff - TRIG_HIST)
  LOC(TRIG_LEVEL_NOT_TOO_HIGH):
    mov(trig_high, r16)
    subi(r17, TRIG_HIST)
    brcc(LOC(TRIG_LEVEL_NOT_TOO_LOW))
    ldi(r17, TRIG_HIST)
  LOC(TRIG_LEVEL_NOT_TOO_LOW):
    mov(trig_low, r17)
    rjmp(LOC(DONE))

  LOC(SET_PWM_PRESCALER):
    rcall(recvd_pop)
    andi(r16, 0x07)
    ori(r16, _BV(WGM22))
    sts(TCCR2B, r16)
    rjmp(LOC(DONE))

  LOC(SET_PWM_TOTAL):
    rcall(recvd_pop_byte)
    sts(OCR2A, r16) ; pwm wave length
    rjmp(LOC(DONE))

  LOC(SET_PWM_ACTIVE):
    rcall(recvd_pop_byte)
    sts(OCR2B, r16) ; pwm wave length
    rjmp(LOC(DONE))

  LOC(DONE):
    pop(r17)
    pop(r16)
    out(SREG, usart_sreg_tmp)
    reti()
ENDFUNC ; USART_RX_vect

FUNCTION(USART_UDRE_vect)
    brts(LOC(DONE))
    in(usart_sreg_tmp, SREG)
    cpi(XH, (samples + NUM_SAMPLES) >> 8)
    brlo(LOC(NEXT_SAMPLE))
    cpi(XL, (samples + NUM_SAMPLES) & 0xff)
    breq(LOC(LAST_SAMPLE))
    brlo(LOC(NEXT_SAMPLE))
    out(SREG, usart_sreg_tmp)
    set()
  LOC(DONE):
    reti()

  LOC(LAST_SAMPLE):
    adiw(XL, 1)
    ldi(r16, 0xff)
    rjmp(LOC(NOT_MAX))
    
  LOC(NEXT_SAMPLE):
    ld(r16, X+)
    cpi(r16, 0xff)
    brne(LOC(NOT_MAX))
    dec(r16)
  LOC(NOT_MAX):
    sts(UDR0, r16)
    out(SREG, usart_sreg_tmp)
    reti()
ENDFUNC ; USART_UDRE_vect

FUNCTION(read_adc)
    ; In: None
    ; Out: r16
    sts(ADCSRA, cmd_start_adc)
  LOC(WAIT_COMPLETE):
    lds(r16, ADCSRA)
    andi(r16, _BV(ADSC))
    brne(LOC(WAIT_COMPLETE))
    lds(r16, ADCH)
    ret
ENDFUNC ; read_adc


; ------------------------------------------------------------------------------

FUNCTION(main)
    ; Switch off unneeded subsystems
    ldi(r16, _BV(PRTWI, PRTIM0, PRSPI0))
    sts(PRR, r16)

    ; B[0..2] are output (lcd)
    in(r16, DDRB)
    ori(r16, 0x07)
    out(DDRB, r16)
    
    ; D[2,4..7] are output (lcd), D3 is output (pwm)
    in(r16, DDRD)
    ori(r16, 0xfc)
    out(DDRD, r16)
    
    ; C0 is input (adc)
    in(r16, DDRC)
    andi(r16, ~_BV(0))
    out(DDRC, r16)
    ; C[0] is analogue input (adc)
    ldi(r16,  _BV(0))
    sts(DIDR0, r16)

    ; Set up Timer2 for FastPWM mode
    ldi(r16, _BV(COM2B1, WGM21, WGM20))
    sts(TCCR2A, r16)
    ldi(r16, _BV(WGM22) | 3) ; FIXME: prescaler hardwired to 16M/32 = 500kHz
    sts(TCCR2B, r16)
    ldi(r16, 250 - 1)
    sts(OCR2A, r16) ; pwm wave length, freq = 500kHz / 250 = 2 kHz
    ldi(r16, 100) 
    sts(OCR2B, r16) ; pwm high state length, must be < wave length, now: 100/250 = 40%

    ; Set up ADC
    ldi(admux, _BV(ADLAR, REFS1, REFS0)) ; input=C0, left adjust, ref=AVcc -> 20 mV per unit
    sts(ADMUX, admux)
    ; Set up delay block address
    ldi(r16, 0)
    rcall(set_sample_rate)

    ; Set up USART recv buffer pointer
    ldi(YL, recv_buf & 0xff)
    ldi(YH, recv_buf >> 8)
    ; Usart to USE_BAUD, 8 data, even pty, 1 stop, rx data irq
    ldi(r16, HI8(USE_BAUD))
    sts(UBRR0H, r16)
    ldi(r16, LO8(USE_BAUD))
    sts(UBRR0L, r16)
    ldi(r16, _BV(U2X0))
    sts(UCSR0A, r16)
    ldi(r16, _BV(UCSZ01, UCSZ00, UPM01)) ; 8bits, even pty, 1 stop
    sts(UCSR0C, r16)
    ldi(r16, _BV(RXEN0, TXEN0, RXCIE0, UDRIE0))
    sts(UCSR0B, r16) ; Enable USART

    ; Set up sample buffer pointer
    ldi(XL, samples & 0xff)
    ldi(XH, samples >> 8)

    ; Set up trigger
    ldi(trig_type, TRIG_RISING)
    ldi(r16, 0x80)
    mov(trig_level, r16)

    ; ------------------------------------------------------------------------------

    ; Read the next sweep of samples
    ;
    ; The point here is to create a delay loop with a constant and a repeatable part
    ; whose sum is a divisor of 16 clks and can express 1600 at top.
    ; I don't want to unroll 1600 `nop`s, at least not until all more civil approaches
    ; have been exhausted, so it'll be a loop with a counter.
    ;
    ; The constant part has to do the actual work (read and store the ADC value,
    ; increment the dest pointer and check for end-of-sweep), so it's at least
    ; 2+2+2+1 + 1+1+(2+2 | 1+1+2) = 13 clks, so when expressing 16, we have two approaches:
    ;
    ; 1. The loop runs once, and the repeating part can be at most 3 clks, which is ok for a `dec; brnz`
    ; 2. The loop runs 0 times, the constant part takes up 16, but this requires a forward-testing loop
    ;
    ; As of approach #1, if the constant part is 13 and the repeatable 3, it's fine for 16, but
    ; even for 32 the loop should run (32-13)/3 = 6 1/3 times, so this option is out.
    ;
    ; Approach #2 is it then, so the constant part is 16, the loop must be a forward-testing
    ; one, the repeatable length must divide 16 clks, and must be at least (1600-16)/255 <= 7
    ; clks long. (At least if I want the counter keep within 8 bits, which I'd prefer to.)
    ;
    ; So the repeatable part is either 8 or 16 clks. Even for a forward-test and jump-back 8
    ; seems fairly enough, so this is the time for some constructive laziness. No point in
    ; optimising a delay loop, remember ;) ?

    ; The loop with the delay code is 2+2+2+(3)+1 + (1+1+1+1+1+1+2)*N + 1+1+(2+2 | 1+1+2) = 16 + 8*N clks
    ; That makes N = clks/8 - 2
    ;
    ; 100 us = 1600 clks, N = 198
    ;  50 us =  800 clks, N =  98
    ;  20 us =  320 clks, N =  38
    ;  10 us =  160 clks, N =  18
    ;   5 us =   80 clks, N =   8
    ;   2 us =   32 clks, N =   2
    ;   1 us =   16 clks, N =   0
    
  LOC(NEXT_SAMPLE_PLUS_2): ; NOTE: we need to equalise the cases when the 1st and when the 2nd `cpi` decides to jump back
    rjmp(LOC(NEXT_SAMPLE)) ; 2 clks
  LOC(NEXT_SAMPLE):
    cli() ; 1 clk
    lds(r16, ADCH) ; 2 clk
    sts(ADCSRA, cmd_start_adc) ; 2 clk
    st(X+, r16) ; 2 clk


    mov(r16, delay_counter_max) ; 1 clk
    ; wait starts
  LOC(WAIT_LOOP):
    tst(r16); 1 clk
    breq(LOC(WAIT_DONE)) ; calculate as 1 clk, add the 2nd (if jump taken) later
    dec(r16) ; 1 clk
    nop() ; 1 clk
    nop() ; 1 clk
    nop() ; 1 clk
    rjmp(LOC(WAIT_LOOP)) ; 2 clks
  LOC(WAIT_DONE):
    ; wait done

    ; +1 clk, because the `breq` above takes 2 when it actually jumps here
    cpi(XH, (samples + NUM_SAMPLES) >> 8) ; 1 clk
    brne(LOC(NEXT_SAMPLE_PLUS_2)) ; 2 clks if branch taken, 1 clk if staying here
    cpi(XL, (samples + NUM_SAMPLES) & 0xff) ; 1 clk
    brne(LOC(NEXT_SAMPLE)) ; 2 clks if branch taken, 1 clk if staying here


    ; Send the samples to the USART
    ldi(XL, samples & 0xff)
    ldi(XH, samples >> 8)
    clt()
    rcall(USART_UDRE_vect) ; will enable interrupts on return
    
  LOC(WAIT_SEND_COMPLETE):
    ; USART_UDRE_vect will set T flag when finished
    brtc(LOC(WAIT_SEND_COMPLETE))

    ; Set up sample buffer pointer
    ldi(XL, samples & 0x0f)
    ldi(XH, samples >> 8)

    cpi(trig_type, TRIG_RISING)
    breq(LOC(WAIT_TRIG_RISING))
    cpi(trig_type, TRIG_FALLING)
    brne(LOC(NEXT_SAMPLE))

  LOC(WAIT_TRIG_FALLING): ; wait for trig pre-condition
    rcall(read_adc)
    cp(r16, trig_high)
    brlo(LOC(WAIT_TRIG_FALLING))
  LOC(WAIT_TRIG_FALLING_2): ; wait for trig condition
    ; rcall(read_adc) ; inlined below to reclaim 3+4 clks of `rcall + ret`
    sts(ADCSRA, cmd_start_adc)
  LOC(WAIT_COMPLETE_F):
    lds(r16, ADCSRA)
    andi(r16, _BV(ADSC))
    brne(LOC(WAIT_COMPLETE_F))
    lds(r16, ADCH)
    cp(r16, trig_low)
    brlo(LOC(NEXT_SAMPLE))
    rjmp(LOC(WAIT_TRIG_FALLING_2))

  LOC(WAIT_TRIG_RISING): ; wait for trig pre-condition
    rcall(read_adc)
    cp(r16, trig_low)
    brsh(LOC(WAIT_TRIG_RISING))
  LOC(WAIT_TRIG_RISING_2): ; wait for trig condition
    ;rcall(read_adc) ; inlined below to reclaim 3+4 clks of `rcall + ret`
    sts(ADCSRA, cmd_start_adc)
  LOC(WAIT_COMPLETE_R):
    lds(r16, ADCSRA)
    andi(r16, _BV(ADSC))
    brne(LOC(WAIT_COMPLETE_R))
    lds(r16, ADCH)
    cp(r16, trig_high)
    brsh(LOC(NEXT_SAMPLE))
    jmp(LOC(WAIT_TRIG_RISING_2))

ENDFUNC ; main


; ------------------------------------------------------------------------------

led_b210:   .DB 3, 0, 5, 5, 6, 7, 7, 0, 7, 7, 6, 7, 3, 5, 7, 6
led_d7654:  .DB 0xf0, 0x30, 0xe0, 0x70, 0x30, 0x50, 0xd0, 0x70, 0xf0, 0x70, 0xf0, 0x90, 0xc0, 0xb0, 0xc0, 0xc0


; ------------------------------------------------------------------------------
.DSEG
recv_buf:           .byte 1*RECV_BUF_SIZE
samples:            .byte 1*NUM_SAMPLES

;{ vim: set sw=4 ts=4 ft=asm et: }
