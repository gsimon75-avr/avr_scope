; Expected symbols (via -Dname=value in commandline)
; F_CPU	cpu freq in Hz

include(boilerplate.m4)
include(iosyms.m4)

define({RECV_BUF_SIZE}, 4)
define({END_OF_TRACE}, 0xffff)
define({USE_BAUD}, BAUDVALUE(2000000))

; register mapping
; multiplication result, used by ADC_vect and ADC setup: r0, r1
define({usart_sreg_tmp}, r12)
define({adc_sreg_tmp}, r14)
; generic working registers: r16, r17
; recv_ptr Y[H,L], used by recvd_push and recvd_pop: r28, r29
; pointer to pgm mem constants Z[H,L], used by led_num and set_sample_rate: r30, r31

; ------------------------------------------------------------------------------
.org 0
jmp(main)

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

;rjmp(TIMER1_COMPB_vect)
reti
nop

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rjmp(USART_RX_vect)
nop

rcall(trap)
nop()

rcall(trap)
nop()

jmp(ADC_vect)
nop

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

rcall(trap)
nop()

.CSEG
FUNCTION(trap)
	cli
	pop(r16)
	lsr(r16)
	lsr(r16)
	dec(r16)
	rcall(led_num)
	ldi(r16, 1)
	rcall(led_dot)
  LOC(q):
	rjmp(LOC(q))
ENDFUNC


; ------------------------------------------------------------------------------
.CSEG

FUNCTION(led_num)
	; In: r16 = n
	; Out: none
	; Changes: SREG, Z
	
	cpi(r16, 0x10)
	brsh(LOC(OFF))

	mov(ZL, r16)
	clr(ZH)
	addiw(ZL, ZH, led_b210 << 1)
	lpm(ZH, Z)
	in(ZL, PORTB)
	andi(ZL, 0xf8)
	or(ZL, ZH)
	out(PORTB, ZL)
	
	mov(ZL, r16)
	clr(ZH)
	addiw(ZL, ZH, led_d7654 << 1)
	lpm(ZH, Z)
	in(ZL, PORTD)
	andi(ZL, 0x0f)
	or(ZL, ZH)
	out(PORTD, ZL)
	ret

  LOC(OFF):
	in(ZL, PORTB)
	andi(ZL, 0xf8)
	out(PORTB, ZL)
	
	in(ZL, PORTD)
	andi(ZL, 0x0f)
	out(PORTD, ZL)
	ret
ENDFUNC ; led_num


FUNCTION(led_dot)
	; In: r16 = onoff
	; Out: none
	; Changes: SREG, ZL
	in(ZL, PORTD)
	andi(ZL, 0xfb)
	sbrc(r16, 0)
	ori(ZL, 0x04)
	out(PORTD, ZL)
	ret
ENDFUNC ; led_dot


FUNCTION(led_onoff)
	; In: r16 = onoff
	; Out: none
	; Changes: SREG
	cpi(r16, 0)
	breq(LOC(OFF))
	sbi(PORTD, 3)
	ret

  LOC(OFF):
	cbi(PORTD, 3)
	ret
ENDFUNC ; led_onoff


FUNCTION(set_sample_rate)
	; In: r16 = idx
	; Out: none
	; Changes: SREG, Z, r17, r16
	;
	mov(ZL, r16)
	clr(ZH)
	addiw(ZL, ZH, adcsra_values << 1)
	lpm(r17, Z)
	sts(ADCSRA, r17)
	
	add(r16, r16)
	add(r16, r16)

	mov(ZL, r16)
	clr(ZH)
	addiw(ZL, ZH, sample_clks << 1)
	lpm(r16, Z+)
	lpm(r17, Z+)
	sts(OCR1AH, r17)
	sts(OCR1AL, r16)

	lpm(r16, Z)
	sts(TCCR1B, r16)

	clr(r16)
	sts(TCNT1H, r16)
	sts(TCNT1L, r16)
	ret
ENDFUNC ; set_sample_rate


FUNCTION(recvd_push)
	; In: r16 = x
	; Out: None
	; Changes: Y
	;
	; check wrap -> store -> increment
	cpi(YH, (recv_buf + RECV_BUF_SIZE) >> 8)
	brlo(LOC(NO_WRAP_AROUND))
	cpi(YL, (recv_buf + RECV_BUF_SIZE) & 0xff)
	brlo(LOC(NO_WRAP_AROUND))
	ldi(YL, recv_buf & 0x0f)
	ldi(YH, recv_buf >> 8)
  LOC(NO_WRAP_AROUND):
	st(Y+, r16)
	ret
ENDFUNC ; recvd_push


FUNCTION(recvd_pop)
	; In: none
	; Out: r16 = x
	; Changes: Y
	;
	; decrement -> load -> check wrap
	ld(r16, -Y)
	cpi(YH, recv_buf >> 8)
	brlo(LOC(WRAP_AROUND))
	brne(LOC(NO_WRAP_AROUND))
	cpi(YL, recv_buf & 0xff)
	brsh(LOC(NO_WRAP_AROUND))
  LOC(WRAP_AROUND):
	ldi(YL, (recv_buf + RECV_BUF_SIZE) & 0x0f)
	ldi(YH, (recv_buf + RECV_BUF_SIZE) >> 8)
  LOC(NO_WRAP_AROUND):
  	ret
ENDFUNC ; recvd_pop


FUNCTION(recvd_pop_byte)
	; In: none
	; Out: r16 = x
	; Changes: Z, r17
	rcall(recvd_pop)
	mov(r17, r16)
	rcall(recvd_pop)
	lsl(r16)
	lsl(r16)
	lsl(r16)
	lsl(r16)
	or(r16, r17)
	ret
ENDFUNC ; recvd_pop_byte


FUNCTION(USART_RX_vect)
	in(usart_sreg_tmp, SREG)

	lds(r16, UDR0)

	cpi(r16, 'S')
	breq(LOC(SET_SPEED))
	cpi(r16, 'R')
	breq(LOC(SET_VREF))
	cpi(r16, 'P')
	breq(LOC(SET_PWM_PRESCALER))
	cpi(r16, 'T')
	breq(LOC(SET_PWM_TOTAL))
	cpi(r16, 'A')
	breq(LOC(SET_PWM_ACTIVE))

	cpi(r16, '0')
	brlt(LOC(DONE))
	cpi(r16, '9' + 1)
	brge(LOC(NOT_09))
	subi(r16, '0')
	rjmp(LOC(DIGIT))

  LOC(NOT_09):
	cpi(r16, 'A')
	brlt(LOC(DONE))
	cpi(r16, 'F' + 1)
	brge(LOC(NOT_AF))
	subi(r16, 'A' - 10)
	rjmp(LOC(DIGIT))

  LOC(NOT_AF):
	cpi(r16, 'a')
	brlt(LOC(DONE))
	cpi(r16, 'f' + 1)
	brge(LOC(DONE))
	subi(r16, 'a' - 10)

  LOC(DIGIT):
	rcall(recvd_push)

  LOC(DONE):
	out(SREG, usart_sreg_tmp)
	reti

  LOC(SET_SPEED):
  	rcall(recvd_pop)
	andi(r16, 0x07)
	rcall(set_sample_rate)
	rjmp(LOC(DONE))

  LOC(SET_VREF):
  	rcall(recvd_pop)
	andi(r16, 0x01)
	sbrc(r16, 0)
	ldi(r16, _BV(REFS1)) ; ref=AVcc
	addi(r16, _BV(ADLAR, REFS1, REFS0) | 0) ; input=C0, left adjust, ref={AVcc or bandgap 1.1V}
	sts(ADMUX, r16)
	rjmp(LOC(DONE))

  LOC(SET_PWM_PRESCALER):
  	rcall(recvd_pop)
	andi(r16, 0x07)
	ori(r16, _BV(WGM22))
	sts(TCCR2B, r16)
	rjmp(LOC(DONE))

  LOC(SET_PWM_TOTAL):
  	rcall(recvd_pop_byte)
	sts(OCR2A, r16) ; pwm wave length
	rjmp(LOC(DONE))

  LOC(SET_PWM_ACTIVE):
  	rcall(recvd_pop_byte)
	sts(OCR2B, r16) ; pwm wave length
	rjmp(LOC(DONE))
ENDFUNC ; USART_RX_vect


FUNCTION(ADC_vect)
	; Changes: r0, r1
	in(adc_sreg_tmp, SREG)
	lds(r0, ADCH)
	sts(UDR0, r0)
	out(SREG, adc_sreg_tmp)
	reti
ENDFUNC ; ADC_vect
; ------------------------------------------------------------------------------

define({BAUDVALUE}, {eval((F_CPU / (8*($1))) - 1)})

FUNCTION(main)
	; Switch off unneeded subsystems
	ldi(r16, _BV(PRTWI, PRTIM0, PRSPI0))
	sts(PRR, r16)

	; Wake from sleep uses 4 clks -> leave disabled
	;clr(r16)
	;sts(SMCR, r16)

	; B[0..2] are output (lcd)
	in(r16, DDRB)
	ori(r16, 0x07)
	out(DDRB, r16)
	
	; D[2,4..7] are output (lcd), D3 is output (pwm)
	in(r16, DDRD)
	ori(r16, 0xfc)
	out(DDRD, r16)
	
	; Set up USART recv buffer pointer
	ldi(YL, recv_buf & 0x0f)
	ldi(YH, recv_buf >> 8)

	; Usart to USE_BAUD, 8 data, even pty, 1 stop, rx data irq
	ldi(r16, HI8(USE_BAUD))
	sts(UBRR0H, r16)
	ldi(r16, LO8(USE_BAUD))
	sts(UBRR0L, r16)
	ldi(r16, _BV(U2X0))
	sts(UCSR0A, r16)
	ldi(r16, _BV(UCSZ01, UCSZ00, UPM01)) ; 8bits, even pty, 1 stop
	sts(UCSR0C, r16)

	; C0 is input (adc)
	in(r16, DDRC)
	andi(r16, ~_BV(0))
	out(DDRC, r16)
	; C[0] is analogue input (adc)
	ldi(r16,  _BV(0))
	sts(DIDR0, r16)

	; Set up Timer2 for FastPWM mode
	ldi(r16, _BV(COM2B1, WGM21, WGM20))
	sts(TCCR2A, r16)
	ldi(r16, _BV(WGM22) | 7) ; FIXME: prescaler is set to 7 -> 8kHz..64Hz
	sts(TCCR2B, r16)
	ldi(r16, 0x30)
	sts(OCR2A, r16) ; pwm wave length
	ldi(r16, 0x20)
	sts(OCR2B, r16) ; pwm high state length, must be < wave length

	; Set up Timer1 for normal operation
	ldi(r16, 5) ; Auto trigger on TC1 CMatch B
	sts(ADCSRB, r16)

	ldi(r16, _BV(ADLAR, REFS0)) ; 20 mV per unit
	sts(ADMUX, r16)

	ldi(r16, 7) ; 500Hz = 2ms per sample
	rcall(set_sample_rate)

	clr(r16)
	sts(OCR1BH, r16)
	sts(OCR1BL, r16)

	ldi(r16, _BV(OCIE1B))
	sts(TIMSK1, r16)

	; Enable USART
	ldi(r16, _BV(RXEN0, TXEN0, RXCIE0))
	sts(UCSR0B, r16)

	sei
 LOC(nirvana):
	rjmp(LOC(nirvana))
ENDFUNC ; main



; ------------------------------------------------------------------------------
.CSEG

led_b210:	.DB 3, 0, 5, 5, 6, 7, 7, 0, 7, 7, 6, 7, 3, 5, 7, 6
led_d7654:	.DB 0xf0, 0x30, 0xe0, 0x70, 0x30, 0x50, 0xd0, 0x70, 0xf0, 0x70, 0xf0, 0x90, 0xc0, 0xb0, 0xc0, 0xc0


; ------------------------------------------------------------------------------
.DSEG
recv_buf:			.byte 1*RECV_BUF_SIZE

; ------------------------------------------------------------------------------
.CSEG

define({CLK_PARAM_HZ}, {ifelse(
	eval((F_CPU /		 $1 ) < 65536), 1,
		.DW eval(F_CPU / $1)
		.DW eval(_BV(WGM12) + 1),
	eval((F_CPU / (  8 * $1)) < 65536), 1,
		.DW eval(F_CPU / (8 * $1))
		.DW eval(_BV(WGM12) + 2),
	eval((F_CPU / ( 64 * $1)) < 65536), 1,
		.DW eval(F_CPU / (64 * $1))
		.DW eval(_BV(WGM12) + 3),
	eval((F_CPU / (256 * $1)) < 65536), 1,
		.DW eval(F_CPU / (256 * $1))
		.DW eval(_BV(WGM12) + 4),

		.DW eval(F_CPU / (1024 * $1))
		.DW eval(_BV(WGM12) + 5)
	)})


sample_clks:
		; [0]: 10 us = 100 kHz
		CLK_PARAM_HZ(100000)
		; [1]: 20 us = 50 kHz
		CLK_PARAM_HZ(50000)
		; [2]: 50 us = 20 kHz
		CLK_PARAM_HZ(20000)
		; [3]: 100 us = 10 kHz
		CLK_PARAM_HZ(10000)
		; [4]: 200 us = 5 kHz
		CLK_PARAM_HZ(5000)
		; [5]: 500 us = 2 kHz
		CLK_PARAM_HZ(2000)
		; [6]: 1 ms = 1 kHz
		CLK_PARAM_HZ(1000)
		; [7]: 2 ms = 500 Hz
		CLK_PARAM_HZ(500)


define({ADCSRA_VALUE}, {eval(_BV(ADEN, ADATE, ADIE) + MAX(1,MSB8(F_CPU/($1*13)))) })

adcsra_values:
		.DB ADCSRA_VALUE(100000), ADCSRA_VALUE(50000), ADCSRA_VALUE(20000), ADCSRA_VALUE(10000), ADCSRA_VALUE(5000), ADCSRA_VALUE(2000), ADCSRA_VALUE(1000), ADCSRA_VALUE(500)

;{ vim: set sw=4 ts=4 ft=asm noet: }
